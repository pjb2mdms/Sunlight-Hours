<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Sunlight Comparator</title>
<style>
  :root {
    --blue: #0b5fb3;
    --orange: #f28e2b;
    --text: #222;
    --bg: #fff;
    --border: #d9e2ef;
  }

  * { box-sizing: border-box; }

  body {
    font-family: "Helvetica Neue", Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    margin: 0;
    padding: 0;
  }

  header {
    background: var(--blue);
    color: #fff;
    text-align: center;
    padding: 1.25rem 0;
  }

  main {
    max-width: 900px;
    margin: 2rem auto;
    padding: 0 1rem;
  }

  #location {
    text-align: center;
    font-size: 1.1rem;
    margin-bottom: 1.2rem;
  }

  #location span {
    font-weight: bold;
  }

  .controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 1rem;
    margin-bottom: 1rem;
    align-items: end;
  }

  .controls > div { min-width: 160px; }

  label {
    font-weight: 600;
    display: block;
    margin-bottom: 0.25rem;
  }

  input[type="date"], select, input[readonly] {
    padding: 0.45rem 0.6rem;
    font-size: 1rem;
    border: 1px solid var(--border);
    border-radius: 0.4rem;
    width: 100%;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 1rem;
    margin-top: 0.5rem;
  }

  th, td {
    border-bottom: 1px solid var(--border);
    padding: 0.6rem 0.4rem;
    text-align: center;
  }

  th.label-col {
    text-align: left;
    width: 220px;
    font-weight: 700;
  }

  thead th {
    background: #f6fbff;
    position: sticky;
    top: 0;
  }

  #status {
    text-align: center;
    color: #777;
    margin-top: 1rem;
    font-size: 0.9rem;
  }

  @media (max-width: 680px) {
    main { padding: 0 0.6rem; }
    th.label-col { width: 140px; }
    .controls { gap: 0.6rem; }
  }
</style>
</head>
<body>
<header><h1>Sunlight Comparator</h1></header>

<main>
  <div id="location">üìç Detecting location...</div>

  <div class="controls">
    <div>
      <label for="dateInput">Selected Date</label>
      <input type="date" id="dateInput" />
    </div>

    <div>
      <label for="equivDate">Equivalent Date</label>
      <input type="text" id="equivDate" readonly />
    </div>

    <div>
      <label for="compareCity">Comparison City</label>
      <select id="compareCity">
        <option value="">(Select city)</option>
      </select>
    </div>
  </div>

  <table aria-live="polite">
    <thead>
      <tr>
        <th class="label-col" scope="col">Metric</th>
        <th id="col0Header" scope="col">Location</th>
        <th id="col1Header" scope="col">Comparison</th>
      </tr>
    </thead>
    <tbody>
      <tr><th class="label-col">Latitude (¬∞)</th><td id="lat0">‚Äî</td><td id="lat1">‚Äî</td></tr>
      <tr><th class="label-col">Longitude (¬∞)</th><td id="lon0">‚Äî</td><td id="lon1">‚Äî</td></tr>
      <tr><th class="label-col">Sunrise (local)</th><td id="sunrise0">‚Äî</td><td id="sunrise1">‚Äî</td></tr>
      <tr><th class="label-col">Sunset (local)</th><td id="sunset0">‚Äî</td><td id="sunset1">‚Äî</td></tr>
      <tr><th class="label-col">Daylight Hours</th><td id="daylight0">‚Äî</td><td id="daylight1">‚Äî</td></tr>
      <tr><th class="label-col">Noon Elevation (¬∞)</th><td id="elev0">‚Äî</td><td id="elev1">‚Äî</td></tr>
    </tbody>
  </table>

  <div id="status"></div>
</main>

<script>
/* ---------- Math utilities ---------- */
const toRad = d => d * Math.PI / 180;
const toDeg = r => r * 180 / Math.PI;

function solarDeclination(day) {
  return 23.44 * Math.sin(toRad((360 / 365) * (day - 81)));
}

function equationOfTime(day) {
  const B = toRad((360 / 365) * (day - 81));
  return 9.87 * Math.sin(2 * B) - 7.53 * Math.cos(B) - 1.5 * Math.sin(B);
}

function daylightHours(lat, day) {
  const dec = toRad(solarDeclination(day));
  const latR = toRad(lat);
  const cosH = -Math.tan(latR) * Math.tan(dec);
  if (cosH >= 1) return 0;
  if (cosH <= -1) return 24;
  const H = Math.acos(cosH);
  return (2 * toDeg(H)) / 15;
}

function noonElevation(lat, day) {
  const dec = solarDeclination(day);
  return 90 - Math.abs(lat - dec);
}

function dayOfYear(date) {
  const start = new Date(date.getFullYear(), 0, 0);
  return Math.floor((date - start) / 86400000);
}

function dateFromDay(year, day) {
  const d = new Date(year, 0);
  d.setDate(day);
  return d;
}

function findEquivalentDate(lat, targetElev, refDay, year) {
  let best = null, smallestDiff = Infinity;
  for (let d = 1; d <= 365; d++) {
    const elev = noonElevation(lat, d);
    const diff = Math.abs(elev - targetElev);
    if (Math.abs(d - refDay) < 30) continue;
    if (diff < smallestDiff) { smallestDiff = diff; best = d; }
  }
  return best ? dateFromDay(year, best) : null;
}

function fmtDate(d) {
  return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
}

/* ---------- Sunrise/Sunset with timezone awareness ---------- */
function sunriseSunset(lat, lon, day, tzOffsetMinutes = 0) {
  const dec = toRad(solarDeclination(day));
  const latR = toRad(lat);
  const solarDep = toRad(-0.83);
  const cosH = (Math.sin(solarDep) - Math.sin(latR) * Math.sin(dec)) / (Math.cos(latR) * Math.cos(dec));

  if (cosH > 1) return { sunrise: '‚Äî', sunset: '‚Äî' };
  if (cosH < -1) return { sunrise: '‚Äî', sunset: '‚Äî' };

  const H = Math.acos(cosH);
  const Hhours = toDeg(H) / 15;
  const EoT = equationOfTime(day);
  const tzHours = tzOffsetMinutes / 60;
  const tzMeridian = 15 * Math.round(tzHours);
  const solarNoon = 12 - (lon - tzMeridian) / 15 - EoT / 60;
  const sunrise = solarNoon - Hhours;
  const sunset = solarNoon + Hhours;
  return {
    sunrise: formatHoursRounded(sunrise),
    sunset: formatHoursRounded(sunset)
  };
}

function formatHoursRounded(hours) {
  let hNorm = (hours + 24) % 24;
  const h = Math.floor(hNorm);
  let m = Math.round((hNorm - h) * 60);
  if (m === 60) { m = 0; hNorm = (hNorm + 1) % 24; }
  const displayH = ((h + 11) % 12) + 1;
  const ampm = h >= 12 ? 'PM' : 'AM';
  return `${displayH}:${m.toString().padStart(2, '0')} ${ampm}`;
}

/* ---------- City list (subset for brevity; same format as before) ---------- */
const CITIES = [
  { id: 'Houston, TX, USA', name: 'Houston, TX (USA)', lat: 29.7604, lon: -95.3698, tz: 'America/Chicago' },
  { id: 'St Andrews, UK', name: 'St Andrews (UK)', lat: 56.3398, lon: -2.7966, tz: 'Europe/London' },
  { id: 'Tokyo, Japan', name: 'Tokyo (Japan)', lat: 35.6762, lon: 139.6503, tz: 'Asia/Tokyo' },
  { id: 'Sydney, Australia', name: 'Sydney (Australia)', lat: -33.8688, lon: 151.2093, tz: 'Australia/Sydney' }
  // ... (include full list as before if desired)
];

/* ---------- DOM + logic ---------- */
const dateInput = document.getElementById('dateInput');
const equivField = document.getElementById('equivDate');
const compareSelect = document.getElementById('compareCity');
const daylight0 = document.getElementById('daylight0');
const daylight1 = document.getElementById('daylight1');
const elev0 = document.getElementById('elev0');
const elev1 = document.getElementById('elev1');
const col0Header = document.getElementById('col0Header');
const col1Header = document.getElementById('col1Header');
const lat0 = document.getElementById('lat0'), lat1 = document.getElementById('lat1');
const lon0 = document.getElementById('lon0'), lon1 = document.getElementById('lon1');
const sunr0 = document.getElementById('sunrise0'), sunr1 = document.getElementById('sunrise1');
const suns0 = document.getElementById('sunset0'), suns1 = document.getElementById('sunset1');
const locationEl = document.getElementById('location');

let primaryLat = 27.95, primaryLon = -82.46, primaryName = 'Tampa, FL (fallback)';
let compareCity = null;

function populateCityDropdown() {
  CITIES.sort((a,b)=>a.name.localeCompare(b.name));
  for (const c of CITIES) {
    const opt = document.createElement('option');
    opt.value = c.id; opt.textContent = c.name;
    compareSelect.appendChild(opt);
  }
}
populateCityDropdown();

function findCityById(id) {
  return CITIES.find(c => c.id === id) || null;
}

function hoursToHM(hours) {
  const h = Math.floor(hours);
  const m = Math.round((hours - h) * 60);
  return `${h} h ${m.toString().padStart(2,'0')} m`;
}

function computeFor(lat, lon, dateObj, tz = Intl.DateTimeFormat().resolvedOptions().timeZone) {
  const day = dayOfYear(dateObj);
  const elev = noonElevation(lat, day);
  const hrs = daylightHours(lat, day);
  const tzOffsetMin = new Date().toLocaleString('en-US', { timeZone: tz });
  const offset = -dateObj.getTimezoneOffset(); // fallback
  const times = sunriseSunset(lat, lon, day, offset);
  return { elev, hrs, sunrise: times.sunrise, sunset: times.sunset };
}

function renderColumns(primary, comparison, dateObj) {
  col0Header.textContent = primary.name;
  lat0.textContent = primary.lat.toFixed(1);
  lon0.textContent = primary.lon.toFixed(1);
  const p = computeFor(primary.lat, primary.lon, dateObj);
  sunr0.textContent = p.sunrise;
  suns0.textContent = p.sunset;
  daylight0.textContent = hoursToHM(p.hrs);
  elev0.textContent = p.elev.toFixed(2);

  if (comparison) {
    col1Header.textContent = comparison.name;
    lat1.textContent = comparison.lat.toFixed(1);
    lon1.textContent = comparison.lon.toFixed(1);
    const c = computeFor(comparison.lat, comparison.lon, dateObj, comparison.tz);
    sunr1.textContent = c.sunrise;
    suns1.textContent = c.sunset;
    daylight1.textContent = hoursToHM(c.hrs);
    elev1.textContent = c.elev.toFixed(2);
  } else {
    col1Header.textContent = '‚Äî';
    lat1.textContent = lon1.textContent = sunr1.textContent = suns1.textContent = daylight1.textContent = elev1.textContent = '‚Äî';
  }
}

function updateValues() {
  if (!dateInput.value) return;
  const d = new Date(dateInput.value + "T00:00");
  const year = d.getFullYear();
  const dayNum = dayOfYear(d);
  const primaryElev = noonElevation(primaryLat, dayNum);
  const eqDate = findEquivalentDate(primaryLat, primaryElev, dayNum, year);
  equivField.value = eqDate ? fmtDate(eqDate) : '‚Äî';
  const primary = { name: primaryName, lat: primaryLat, lon: primaryLon };
  const comparison = compareCity ? { name: compareCity.name, lat: compareCity.lat, lon: compareCity.lon, tz: compareCity.tz } : null;
  renderColumns(primary, comparison, d);
}

compareSelect.addEventListener('change', ()=>{
  const val = compareSelect.value;
  compareCity = val ? findCityById(val) : null;
  updateValues();
});
dateInput.addEventListener('change', updateValues);

function init() {
  const today = new Date();
  dateInput.value = today.toLocaleDateString('en-CA');
  col0Header.textContent = 'Current Location';
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(pos=>{
      primaryLat = pos.coords.latitude;
      primaryLon = pos.coords.longitude;
      primaryName = 'Your Location';
      locationEl.innerHTML = `üìç Location: <span>${primaryName}</span> (${primaryLat.toFixed(1)}¬∞, ${Math.abs(primaryLon).toFixed(1)}¬∞ ${primaryLon<0?'W':'E'})`;
      updateValues();
    },()=>{
      locationEl.innerHTML = "üìç Using default location: <span>Tampa, FL</span>";
      updateValues();
    });
  } else updateValues();
}
init();
</script>
</body>
</html>
