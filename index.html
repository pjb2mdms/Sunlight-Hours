<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Sunlight Comparator</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1"></script>
<style>
:root{--blue:#0b5fb3;--orange:#f28e2b;--green:#10b981;--text:#222;--bg:#f8fafc;--card:#fff;}
body{font-family:"Helvetica Neue",Arial,sans-serif;margin:0;color:var(--text);background:var(--bg);}
header{background:linear-gradient(135deg,#0b5fb3 0%,#084a8f 100%);color:#fff;text-align:center;padding:2rem 1rem;box-shadow:0 2px 8px rgba(0,0,0,.1);}
header h1{margin:0;font-size:2.2rem;font-weight:300;letter-spacing:.5px;}
header p{margin:.5rem 0 0;opacity:.9;font-size:1rem;}
main{max-width:1100px;margin:2rem auto 3rem;padding:0 1rem;}
.card{background:var(--card);border-radius:12px;padding:1.5rem;margin:1.5rem 0;box-shadow:0 1px 3px rgba(0,0,0,.08);}
.city-selectors{display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;}
@media(max-width:768px){.city-selectors{grid-template-columns:1fr;}}
.selector-group{display:flex;flex-direction:column;gap:.5rem;}
.selector-group label{font-weight:600;font-size:.95rem;color:#555;display:flex;align-items:center;gap:.5rem;}
.selector-group select{font:inherit;font-size:1rem;padding:.7rem;border:2px solid #e2e8f0;border-radius:8px;background:#fff;transition:all .2s;}
.selector-group select:hover{border-color:#cbd5e1;}
.selector-group select:focus{outline:none;border-color:var(--blue);box-shadow:0 0 0 3px rgba(11,95,179,.1);}

.date-earth-section{display:grid;grid-template-columns:160px 1fr;gap:1.5rem;align-items:center;margin-bottom:1.5rem;padding:1.2rem;background:#f8fafc;border-radius:8px;}
@media(max-width:768px){.date-earth-section{grid-template-columns:1fr;}}
.earth-container{position:relative;width:160px;height:160px;margin:0 auto;}
.earth-canvas{width:100%;height:100%;border-radius:50%;box-shadow:0 4px 12px rgba(0,0,0,.15);}
.slider-controls{flex:1;}
.live-dates{font-weight:600;margin-bottom:1rem;display:flex;justify-content:center;gap:1rem;flex-wrap:wrap;align-items:center;}
.live-dates span{display:inline-block;padding:.5rem 1rem;background:#fff;border-radius:6px;box-shadow:0 1px 2px rgba(0,0,0,.05);}
.date-label{font-size:.85rem;color:#666;display:block;}
.date-value{font-size:1.1rem;color:#000;}
.date-selected{border:2px solid #1e293b;}
.date-equiv{border:2px solid #e11d48;}
input[type="range"]{-webkit-appearance:none;appearance:none;width:100%;max-width:800px;height:8px;background:linear-gradient(to right,#e2e8f0 0%,#cbd5e1 100%);border-radius:4px;outline:none;margin:1rem 0;}
input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:20px;height:20px;border-radius:50%;background:var(--blue);border:3px solid #fff;box-shadow:0 2px 4px rgba(0,0,0,.2);cursor:pointer;transition:all .2s;}
input[type="range"]::-webkit-slider-thumb:hover{transform:scale(1.1);}
input[type="range"]::-moz-range-thumb{width:20px;height:20px;border-radius:50%;background:var(--blue);border:3px solid #fff;box-shadow:0 2px 4px rgba(0,0,0,.2);cursor:pointer;}
.note{font-size:.85rem;color:#666;margin-top:.5rem;text-align:center;}

.chart-section{display:grid;grid-template-columns:auto 1fr auto;gap:1.5rem;align-items:start;}
@media(max-width:968px){.chart-section{grid-template-columns:1fr;}}

.vertical-tabs{display:flex;flex-direction:column;gap:.5rem;padding-top:2rem;}
@media(max-width:968px){.vertical-tabs{flex-direction:row;flex-wrap:wrap;padding-top:0;justify-content:center;margin-bottom:1rem;}}
.vertical-tabs button{font:inherit;font-weight:600;padding:.7rem 1rem;border-radius:8px;border:2px solid #e2e8f0;cursor:pointer;background:#fff;color:#333;transition:all .2s;white-space:nowrap;min-width:140px;}
@media(max-width:968px){.vertical-tabs button{min-width:auto;flex:1;}}
.vertical-tabs button:hover{background:#f8fafc;}
.vertical-tabs button.active{background:var(--blue);color:#fff;border-color:var(--blue);}
.vertical-tabs button.active-green{background:var(--green);color:#fff;border-color:var(--green);}

.chart-and-table{flex:1;min-width:0;}
.chart-container{position:relative;height:400px;margin-bottom:1.5rem;}

.data-table-section{min-width:280px;}
@media(max-width:968px){.data-table-section{min-width:0;}}
table{width:100%;border-collapse:collapse;font-size:.9rem;}
th,td{padding:.7rem .5rem;border-bottom:1px solid #e9eef5;text-align:left;}
th{background:#f8fafc;font-weight:600;color:#555;font-size:.85rem;}
td:first-child{font-weight:500;color:#666;}
td:last-child{text-align:right;}
td svg{width:60px;height:35px;vertical-align:middle;margin-left:auto;display:block;}
.city-header{background:#f1f5f9;font-weight:700;color:#334155;text-align:center;padding:.6rem;}

.icon{display:inline-block;width:18px;height:18px;vertical-align:middle;}

/* SAD Index specific styles */
.sad-score-display{display:flex;justify-content:center;gap:2rem;margin:1rem 0;flex-wrap:wrap;}
.sad-score-card{text-align:center;padding:1.5rem 2rem;border-radius:12px;min-width:140px;}
.sad-score-value{font-size:2.5rem;font-weight:700;margin-bottom:.25rem;}
.sad-score-label{font-size:.85rem;font-weight:600;text-transform:uppercase;letter-spacing:1px;opacity:.9;}
.sad-score-city{font-size:.75rem;margin-top:.5rem;opacity:.7;}
.sad-category{font-size:.9rem;font-weight:600;margin-top:.5rem;padding:.25rem .75rem;border-radius:20px;display:inline-block;}

.sad-breakdown{margin-top:1rem;}
.sad-breakdown-title{font-size:.85rem;font-weight:600;color:#555;margin-bottom:.75rem;text-transform:uppercase;letter-spacing:1px;}
.sad-component{margin-bottom:.75rem;}
.sad-component-header{display:flex;justify-content:space-between;font-size:.85rem;margin-bottom:.25rem;}
.sad-component-label{color:#666;}
.sad-component-value{font-weight:500;}
.sad-component-bar{height:6px;background:#e2e8f0;border-radius:3px;overflow:hidden;}
.sad-component-fill{height:100%;border-radius:3px;transition:width .4s ease-out;}

.sad-advice{margin-top:1.5rem;padding:1rem;border-radius:8px;font-size:.9rem;line-height:1.5;}

.cloud-control{display:flex;align-items:center;justify-content:center;gap:1rem;margin-top:1rem;padding:.75rem;background:#fff;border-radius:8px;box-shadow:0 1px 2px rgba(0,0,0,.05);}
.cloud-control label{font-size:.9rem;color:#555;display:flex;align-items:center;gap:.5rem;}
.cloud-control input[type="range"]{width:150px;margin:0;}
.cloud-control .cloud-value{font-weight:600;min-width:40px;}

/* Category colors */
.cat-excellent{background:rgba(245,158,11,0.15);color:#b45309;}
.cat-good{background:rgba(132,204,22,0.15);color:#4d7c0f;}
.cat-moderate{background:rgba(34,211,238,0.15);color:#0e7490;}
.cat-low{background:rgba(167,139,250,0.15);color:#6d28d9;}
.cat-verylow{background:rgba(244,114,182,0.15);color:#be185d;}
</style>
</head>
<body>
<header>
<h1>‚òÄÔ∏è Sunlight Comparator</h1>
<p>Compare daylight hours, sun elevation, and SAD Light Index between any two cities</p>
</header>
<main>
<div class="card">
<div class="city-selectors">
<div class="selector-group">
<label><svg class="icon" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>Reference City</label>
<select id="referenceCity"></select>
</div>
<div class="selector-group">
<label><svg class="icon" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>Comparison City</label>
<select id="compareCity"></select>
</div>
</div>
</div>

<div class="card">
<div class="date-earth-section">
<div class="earth-container">
<canvas id="earthCanvas" class="earth-canvas" width="320" height="320"></canvas>
</div>
<div class="slider-controls">
<div class="live-dates">
<span class="date-selected"><span class="date-label">Selected Date</span><span class="date-value" id="selectedLabel">‚Äî</span></span>
<span class="date-equiv"><span class="date-label">Equivalent Date</span><span class="date-value" id="equivLabel">‚Äî</span></span>
</div>
<input type="range" id="dateSlider" min="1" max="365" step="1" value="172">
<div class="note">üí° Drag the slider to explore different dates throughout the year</div>
</div>
</div>

<!-- Cloud cover control for SAD mode -->
<div class="cloud-control" id="cloudControl" style="display:none;">
<label>
<span>‚òÅÔ∏è Cloud Cover:</span>
<input type="range" id="cloudSlider" min="0" max="100" value="30">
<span class="cloud-value" id="cloudValue">30%</span>
</label>
<span style="font-size:.8rem;color:#888;">Adjust for current weather conditions</span>
</div>

<div class="chart-section">
<div class="vertical-tabs">
<button id="hoursBtn" class="active">üìä Daylight<br>Hours</button>
<button id="elevBtn">üåû Noon<br>Elevation</button>
<button id="sadBtn">üß† SAD Light<br>Index</button>
</div>
<div class="chart-and-table">
<div class="chart-container"><canvas id="chartCanvas"></canvas></div>
</div>
<div class="data-table-section">
<table id="resultsTable">
<tbody id="tableBody"></tbody>
</table>
</div>
</div>
</div>
</main>
<script>
const cities=[
{lat:52.37,lon:4.89,tz:"Europe/Amsterdam",name:"Amsterdam",country:"Netherlands"},
{lat:47.50,lon:19.04,tz:"Europe/Budapest",name:"Budapest",country:"Hungary"},
{lat:50.85,lon:4.35,tz:"Europe/Brussels",name:"Brussels",country:"Belgium"},
{lat:-34.60,lon:-58.38,tz:"America/Argentina/Buenos_Aires",name:"Buenos Aires",country:"Argentina"},
{lat:35.23,lon:-80.84,tz:"America/New_York",name:"Charlotte, NC",country:"USA"},
{lat:38.03,lon:-78.48,tz:"America/New_York",name:"Charlottesville, VA",country:"USA"},
{lat:64.13,lon:-21.82,tz:"Atlantic/Reykjavik",name:"Reykjavik",country:"Iceland"},
{lat:55.68,lon:12.57,tz:"Europe/Copenhagen",name:"Copenhagen",country:"Denmark"},
{lat:53.35,lon:-6.26,tz:"Europe/Dublin",name:"Dublin",country:"Ireland"},
{lat:42.06,lon:-72.51,tz:"America/New_York",name:"East Longmeadow, MA",country:"USA"},
{lat:60.17,lon:24.94,tz:"Europe/Helsinki",name:"Helsinki",country:"Finland"},
{lat:29.76,lon:-95.37,tz:"America/Chicago",name:"Houston, TX",country:"USA"},
{lat:51.51,lon:-0.13,tz:"Europe/London",name:"London",country:"UK"},
{lat:40.42,lon:-3.70,tz:"Europe/Madrid",name:"Madrid",country:"Spain"},
{lat:19.43,lon:-99.13,tz:"America/Mexico_City",name:"Mexico City",country:"Mexico"},
{lat:59.91,lon:10.75,tz:"Europe/Oslo",name:"Oslo",country:"Norway"},
{lat:45.42,lon:-75.70,tz:"America/Toronto",name:"Ottawa",country:"Canada"},
{lat:9.10,lon:-79.38,tz:"America/Panama",name:"Panama City",country:"Panama"},
{lat:48.85,lon:2.35,tz:"Europe/Paris",name:"Paris",country:"France"},
{lat:33.45,lon:-112.07,tz:"America/Phoenix",name:"Phoenix, AZ",country:"USA"},
{lat:50.08,lon:14.44,tz:"Europe/Prague",name:"Prague",country:"Czech Republic"},
{lat:41.90,lon:12.50,tz:"Europe/Rome",name:"Rome",country:"Italy"},
{lat:-33.45,lon:-70.67,tz:"America/Santiago",name:"Santiago",country:"Chile"},
{lat:56.34,lon:-2.80,tz:"Europe/London",name:"St Andrews",country:"Scotland"},
{lat:59.33,lon:18.06,tz:"Europe/Stockholm",name:"Stockholm",country:"Sweden"},
{lat:27.95,lon:-82.46,tz:"America/New_York",name:"Tampa, FL",country:"USA"},
{lat:38.91,lon:-77.04,tz:"America/New_York",name:"Washington, D.C.",country:"USA"}
];

const toRad=d=>d*Math.PI/180,toDeg=r=>r*180/Math.PI;

// More accurate solar declination using Spencer formula
function solarDeclination(day){
const gamma = (2 * Math.PI / 365) * (day - 1);
const decl = 0.006918 - 0.399912 * Math.cos(gamma) + 0.070257 * Math.sin(gamma)
             - 0.006758 * Math.cos(2 * gamma) + 0.000907 * Math.sin(2 * gamma)
             - 0.002697 * Math.cos(3 * gamma) + 0.00148 * Math.sin(3 * gamma);
return toDeg(decl);
}

// Equation of Time using Spencer formula (returns minutes)
function equationOfTime(day) {
const gamma = (2 * Math.PI / 365) * (day - 1);
const eqTime = 229.18 * (0.000075 + 0.001868 * Math.cos(gamma) - 0.032077 * Math.sin(gamma)
               - 0.014615 * Math.cos(2 * gamma) - 0.040849 * Math.sin(2 * gamma));
return eqTime;
}

function daylightHours(lat,day){
const decR=toRad(solarDeclination(day)),latR=toRad(lat);
const cosH=-Math.tan(latR)*Math.tan(decR);
if(cosH>=1)return 0;
if(cosH<=-1)return 24;
const H=Math.acos(cosH);
return(2*toDeg(H))/15;
}

function noonElevation(lat,day){
const dec=solarDeclination(day);
return 90-Math.abs(lat-dec);
}

function dayOfYear(dt){
return Math.floor((dt-new Date(dt.getFullYear(),0,0))/86400000);
}

function dateFromDay(y,d){
return new Date(y,0,d);
}

function fmtMD(date){
return date.toLocaleDateString("en-US",{month:"short",day:"numeric"}).replace(',','');
}

// ============ SAD LIGHT INDEX CALCULATIONS ============

// Summer solstice reference values (using each city's own latitude for fairness)
const SUMMER_SOLSTICE_DAY = 172; // June 21

function getSummerSolsticeReference(lat) {
    const daylightMins = daylightHours(lat, SUMMER_SOLSTICE_DAY) * 60;
    const elevation = noonElevation(lat, SUMMER_SOLSTICE_DAY);
    const sunriseMins = getSunriseMinutes(lat, SUMMER_SOLSTICE_DAY);
    return {
        daylightMinutes: daylightMins,
        solarNoonElevation: elevation,
        sunriseMinutes: sunriseMins,
        cloudCover: 0
    };
}

function getSunriseMinutes(lat, day) {
    const dec = toRad(solarDeclination(day));
    const latR = toRad(lat);
    const solarDep = toRad(-0.833); // Standard refraction correction
    
    const cosH = (Math.sin(solarDep) - Math.sin(latR) * Math.sin(dec)) / (Math.cos(latR) * Math.cos(dec));
    if (cosH > 1) return 12 * 60; // No sunrise (polar night)
    if (cosH < -1) return 0; // No sunset (midnight sun)
    
    const H = Math.acos(cosH);
    const Hh = toDeg(H) / 15; // Hour angle in hours
    
    // Equation of Time correction
    const EoT = equationOfTime(day); // in minutes
    
    // Solar noon in local solar time is 12:00, but we need clock time
    // For a rough approximation, sunrise = 12:00 - (daylight/2) hours, converted to minutes
    // This is simplified since we're comparing relative values
    const solarNoonMinutes = 12 * 60 - EoT;
    const sunriseMinutes = solarNoonMinutes - (Hh * 60);
    
    return sunriseMinutes;
}

function calculateSADLightIndex(lat, day, cloudCoverPercent = 30) {
    const ref = getSummerSolsticeReference(lat);
    
    // Get values for this date
    const daylightMins = daylightHours(lat, day) * 60;
    const solarElevation = noonElevation(lat, day);
    const sunriseMins = getSunriseMinutes(lat, day);
    
    // Score each component (0-100, where 100 = summer solstice ideal)
    
    // 1. Daylight Duration Score (35% weight)
    const minDaylight = 400; // baseline minimum (~6.5 hours)
    const daylightScore = Math.min(100, Math.max(0, 
        ((daylightMins - minDaylight) / (ref.daylightMinutes - minDaylight)) * 100
    ));
    
    // 2. Solar Elevation Score (30% weight)
    const elevationRatio = Math.sin(toRad(solarElevation)) / Math.sin(toRad(ref.solarNoonElevation));
    const elevationScore = Math.min(100, Math.max(0, elevationRatio * 100));
    
    // 3. Cloud Cover Score (25% weight)
    const cloudScore = 100 - (cloudCoverPercent * 0.8);
    
    // 4. Sunrise Timing Score (10% weight)
    const sunriseDelay = Math.max(0, sunriseMins - ref.sunriseMinutes);
    const sunriseScore = Math.max(0, 100 - (sunriseDelay * 0.8));
    
    // Weighted combination
    const totalScore = Math.round(
        (daylightScore * 0.35) +
        (elevationScore * 0.30) +
        (cloudScore * 0.25) +
        (sunriseScore * 0.10)
    );
    
    return {
        totalScore,
        components: {
            daylight: { score: Math.round(daylightScore), value: daylightMins },
            elevation: { score: Math.round(elevationScore), value: solarElevation },
            cloud: { score: Math.round(cloudScore), value: cloudCoverPercent },
            sunrise: { score: Math.round(sunriseScore), value: sunriseMins }
        }
    };
}

function getSADCategory(score) {
    if (score >= 85) return { label: 'Excellent', class: 'cat-excellent', color: '#f59e0b', advice: 'Great natural light day! Aim for 30+ minutes outdoors, especially in the morning.' };
    if (score >= 70) return { label: 'Good', class: 'cat-good', color: '#84cc16', advice: 'Solid light conditions. Morning outdoor time is recommended.' };
    if (score >= 55) return { label: 'Moderate', class: 'cat-moderate', color: '#22d3ee', advice: 'Consider supplementing natural light with a 10,000 lux light therapy lamp.' };
    if (score >= 40) return { label: 'Low', class: 'cat-low', color: '#a78bfa', advice: 'Light therapy recommended. Prioritize any available outdoor time, even on cloudy days.' };
    return { label: 'Very Low', class: 'cat-verylow', color: '#f472b6', advice: 'Use a 10,000 lux light therapy box for 30 minutes each morning upon waking.' };
}

function formatTimeFromMinutes(mins) {
    const hours = Math.floor(mins / 60);
    const minutes = Math.round(mins % 60);
    const ampm = hours >= 12 ? 'PM' : 'AM';
    const displayHours = hours > 12 ? hours - 12 : (hours === 0 ? 12 : hours);
    return `${displayHours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
}

// ============ END SAD CALCULATIONS ============

function findEquivalentDate(lat,targetHours,refDay,year){
const summerSolstice=172;
const winterSolstice=355;
const distToSummer=Math.abs(refDay-summerSolstice);
const distToWinter=Math.min(Math.abs(refDay-winterSolstice),Math.abs(refDay-(winterSolstice-365)));
const closestSolstice=distToSummer<distToWinter?summerSolstice:winterSolstice;
const mirrorDay=2*closestSolstice-refDay;
let normalizedMirror=mirrorDay;
if(normalizedMirror<1)normalizedMirror+=365;
if(normalizedMirror>365)normalizedMirror-=365;
return dateFromDay(year,normalizedMirror);
}

function findEquivalentAngleDate(lat,targetElev,refDay,year){
let best=null,bestDiff=1e9;
for(let d=1;d<=365;d++){
if(d===refDay)continue;
const elev=noonElevation(lat,d);
const diff=Math.abs(elev-targetElev);
if(diff<bestDiff){
bestDiff=diff;
best=d;
}
}
return best?dateFromDay(year,best):null;
}

function fmtHoursMin(h){
const hrs=Math.floor(h);
const mins=Math.round((h-hrs)*60);
return `${hrs}h ${mins.toString().padStart(2,'0')}m`;
}

function getTimeZoneAbbr(tz){
try{
const fmt=new Intl.DateTimeFormat('en-US',{timeZone:tz,timeZoneName:'short'});
return fmt.formatToParts(new Date()).find(p=>p.type==='timeZoneName').value;
}catch{
return'';
}
}

function getTimes(lat,lon,day,tz){
const dec=toRad(solarDeclination(day)),latR=toRad(lat),solarDep=toRad(-0.833);
const cosH=(Math.sin(solarDep)-Math.sin(latR)*Math.sin(dec))/(Math.cos(latR)*Math.cos(dec));
if(cosH>1||cosH<-1)return{sunrise:'‚Äî',sunset:'‚Äî',hrs:0};
const H=Math.acos(cosH);
const Hh=toDeg(H)/15;
const daylight=2*Hh;
const year=new Date().getFullYear();
const dateObj=new Date(year,0,day);
const month=dateObj.getMonth();
const dayOfMonth=dateObj.getDate();

// Get timezone offset for this specific date (handles DST)
const testDate = new Date(year, month, dayOfMonth, 12, 0, 0);
const utcDate = new Date(testDate.toLocaleString('en-US', { timeZone: 'UTC' }));
const tzDate = new Date(testDate.toLocaleString('en-US', { timeZone: tz }));
const tzOffsetHours = (tzDate - utcDate) / (1000 * 60 * 60);

// Equation of Time correction (convert minutes to hours)
const EoT = equationOfTime(day) / 60;

// Solar noon in UTC, corrected for longitude and Equation of Time
// Standard formula: Solar Noon (UTC) = 12:00 - (longitude/15) - EoT
const solarNoonUTC = 12 - (lon / 15) - EoT;

const sunriseUTC = solarNoonUTC - Hh;
const sunsetUTC = solarNoonUTC + Hh;

const fmtTime=(utcHr)=>{
// Handle day wraparound
let adjustedHr = utcHr;
let dayOffset = 0;
if (adjustedHr < 0) { adjustedHr += 24; dayOffset = -1; }
if (adjustedHr >= 24) { adjustedHr -= 24; dayOffset = 1; }

const hrs=Math.floor(adjustedHr);
const mins=Math.round((adjustedHr-hrs)*60);
const d=new Date(Date.UTC(year,month,dayOfMonth + dayOffset,hrs,mins,0));
return d.toLocaleTimeString('en-US',{timeZone:tz,hour:'numeric',minute:'2-digit'});
};
return{sunrise:fmtTime(sunriseUTC),sunset:fmtTime(sunsetUTC),hrs:daylight};
}

function arcSVG(lat,day,color){
const elev=noonElevation(lat,day);
const R=28,a=Math.min(90,Math.max(0,elev))*Math.PI/180;
const x=26+R*Math.cos(Math.PI-a),y=30-R*Math.sin(Math.PI-a);
return `<svg viewBox='0 0 60 36' style='display:block;margin:0 auto;'><path d='M4 30 A28 28 0 0 1 56 30' stroke='#c9d3e3' stroke-width='1.2' fill='none'/><line x1='26' y1='30' x2='${x.toFixed(1)}' y2='${y.toFixed(1)}' stroke='${color}' stroke-width='2.5'/><circle cx='${x.toFixed(1)}' cy='${y.toFixed(1)}' r='3.5' fill='${color}'/></svg>`;
}

function buildSADBreakdown(result, cityName, color) {
    const c = result.components;
    return `
        <div class="sad-breakdown">
            <div class="sad-breakdown-title">${cityName} Breakdown</div>
            <div class="sad-component">
                <div class="sad-component-header">
                    <span class="sad-component-label">Daylight Duration (35%)</span>
                    <span class="sad-component-value">${fmtHoursMin(c.daylight.value / 60)}</span>
                </div>
                <div class="sad-component-bar">
                    <div class="sad-component-fill" style="width:${c.daylight.score}%;background:${color};"></div>
                </div>
            </div>
            <div class="sad-component">
                <div class="sad-component-header">
                    <span class="sad-component-label">Solar Elevation (30%)</span>
                    <span class="sad-component-value">${c.elevation.value.toFixed(1)}¬∞</span>
                </div>
                <div class="sad-component-bar">
                    <div class="sad-component-fill" style="width:${c.elevation.score}%;background:${color};"></div>
                </div>
            </div>
            <div class="sad-component">
                <div class="sad-component-header">
                    <span class="sad-component-label">Sky Clarity (25%)</span>
                    <span class="sad-component-value">${100 - c.cloud.value}% clear</span>
                </div>
                <div class="sad-component-bar">
                    <div class="sad-component-fill" style="width:${c.cloud.score}%;background:${color};"></div>
                </div>
            </div>
            <div class="sad-component">
                <div class="sad-component-header">
                    <span class="sad-component-label">Sunrise Time (10%)</span>
                    <span class="sad-component-value">${formatTimeFromMinutes(c.sunrise.value)}</span>
                </div>
                <div class="sad-component-bar">
                    <div class="sad-component-fill" style="width:${c.sunrise.score}%;background:${color};"></div>
                </div>
            </div>
        </div>
    `;
}

function buildTable(base,comp,day,mode){
const body=document.getElementById('tableBody');
body.innerHTML='';
const tb1=getTimes(base.lat,base.lon,day,base.tz),tb2=getTimes(comp.lat,comp.lon,day,comp.tz);
const ab1=getTimeZoneAbbr(base.tz),ab2=getTimeZoneAbbr(comp.tz);
const refElev=noonElevation(base.lat,day);
const compElev=noonElevation(comp.lat,day);
const angleDate=findEquivalentAngleDate(comp.lat,refElev,day,new Date().getFullYear());

if(mode==='hours'){
const rows=[
{label:'',value:`<div class="city-header">${base.name}</div>`,span:true},
{label:'Latitude',value:base.lat.toFixed(2)+'¬∞'},
{label:'Sunrise',value:`${tb1.sunrise} ${ab1}`},
{label:'Sunset',value:`${tb1.sunset} ${ab1}`},
{label:'Daylight',value:fmtHoursMin(tb1.hrs)},
{label:'',value:`<div class="city-header">${comp.name}</div>`,span:true},
{label:'Latitude',value:comp.lat.toFixed(2)+'¬∞'},
{label:'Sunrise',value:`${tb2.sunrise} ${ab2}`},
{label:'Sunset',value:`${tb2.sunset} ${ab2}`},
{label:'Daylight',value:fmtHoursMin(tb2.hrs)}
];
rows.forEach(r=>{
const tr=document.createElement('tr');
if(r.span){
tr.innerHTML=`<td colspan="2">${r.value}</td>`;
}else{
tr.innerHTML=`<td>${r.label}</td><td>${r.value}</td>`;
}
body.appendChild(tr);
});
}else if(mode==='elev'){
const rows=[
{label:'',value:`<div class="city-header">${base.name}</div>`,span:true},
{label:'Latitude',value:base.lat.toFixed(2)+'¬∞'},
{label:'Noon Elevation',value:`${refElev.toFixed(1)}¬∞`},
{label:'',value:arcSVG(base.lat,day,'#0b5fb3'),span:true},
{label:'',value:`<div class="city-header">${comp.name}</div>`,span:true},
{label:'Latitude',value:comp.lat.toFixed(2)+'¬∞'},
{label:'Noon Elevation',value:`${compElev.toFixed(1)}¬∞`},
{label:'',value:arcSVG(comp.lat,day,'#f28e2b'),span:true},
{label:'',value:'<div style="height:8px"></div>',span:true},
{label:'Equivalent Angle',value:angleDate?`${refElev.toFixed(1)}¬∞ on ${fmtMD(angleDate)}`:'‚Äî',span:true}
];
rows.forEach(r=>{
const tr=document.createElement('tr');
if(r.span){
tr.innerHTML=`<td colspan="2">${r.value}</td>`;
}else{
tr.innerHTML=`<td>${r.label}</td><td>${r.value}</td>`;
}
body.appendChild(tr);
});
}else if(mode==='sad'){
    // SAD Light Index mode
    const cloudCover = Number(document.getElementById('cloudSlider').value);
    const sadBase = calculateSADLightIndex(base.lat, day, cloudCover);
    const sadComp = calculateSADLightIndex(comp.lat, day, cloudCover);
    const catBase = getSADCategory(sadBase.totalScore);
    const catComp = getSADCategory(sadComp.totalScore);
    
    // Find the worse score for advice
    const worseScore = Math.min(sadBase.totalScore, sadComp.totalScore);
    const worseCategory = getSADCategory(worseScore);
    
    body.innerHTML = `
        <tr><td colspan="2">
            <div class="sad-score-display">
                <div class="sad-score-card" style="background:${catBase.color}22;border:2px solid ${catBase.color}44;">
                    <div class="sad-score-value" style="color:${catBase.color};">${sadBase.totalScore}</div>
                    <div class="sad-score-label" style="color:${catBase.color};">${catBase.label}</div>
                    <div class="sad-score-city">${base.name}</div>
                </div>
                <div class="sad-score-card" style="background:${catComp.color}22;border:2px solid ${catComp.color}44;">
                    <div class="sad-score-value" style="color:${catComp.color};">${sadComp.totalScore}</div>
                    <div class="sad-score-label" style="color:${catComp.color};">${catComp.label}</div>
                    <div class="sad-score-city">${comp.name}</div>
                </div>
            </div>
        </td></tr>
        <tr><td colspan="2">${buildSADBreakdown(sadBase, base.name, '#0b5fb3')}</td></tr>
        <tr><td colspan="2">${buildSADBreakdown(sadComp, comp.name, '#f28e2b')}</td></tr>
        <tr><td colspan="2">
            <div class="sad-advice ${worseCategory.class}">
                üí° <strong>Recommendation:</strong> ${worseCategory.advice}
            </div>
        </td></tr>
        <tr><td colspan="2">
            <div style="font-size:.8rem;color:#888;margin-top:.5rem;line-height:1.5;">
                <strong>About this index:</strong> The SAD Light Index (0-100) compares daily light conditions 
                to each city's summer solstice as a reference. Based on research showing that ~5,000 lux-hours 
                daily helps manage SAD symptoms. Scores are weighted: daylight duration (35%), solar elevation (30%), 
                sky clarity (25%), and sunrise timing (10%).
            </div>
        </td></tr>
    `;
}
}

let chart,mode='hours',chartData=null;

function prepareChartData(base,comp){
const daysRaw=[];
for(let d=355;d<=365;d++)daysRaw.push(d);
for(let d=1;d<=356;d++)daysRaw.push(d);
const days=Array.from({length:daysRaw.length},(_,i)=>i+1);
const dataHours={
base:daysRaw.map(d=>daylightHours(base.lat,d)),
comp:daysRaw.map(d=>daylightHours(comp.lat,d))
};
const dataElev={
base:daysRaw.map(d=>noonElevation(base.lat,d)),
comp:daysRaw.map(d=>noonElevation(comp.lat,d)),
threshold:noonElevation(base.lat,355)
};
const cloudCover = Number(document.getElementById('cloudSlider').value);
const dataSAD={
base:daysRaw.map(d=>calculateSADLightIndex(base.lat,d,cloudCover).totalScore),
comp:daysRaw.map(d=>calculateSADLightIndex(comp.lat,d,cloudCover).totalScore)
};
return{days,daysRaw,dataHours,dataElev,dataSAD,base,comp};
}

function drawChart(refDay,eqDate,angleDate,refElev){
if(!chartData)return;
const ctx=document.getElementById("chartCanvas").getContext("2d");
const {days,daysRaw,dataHours,dataElev,dataSAD,base,comp}=chartData;

let data, lbl, yCfg;
if(mode==="hours"){
    data=dataHours;
    lbl="Daylight Hours";
    yCfg={min:5,max:20};
}else if(mode==="elev"){
    data=dataElev;
    lbl="Noon Elevation (¬∞)";
    yCfg={min:0,max:90};
}else{
    data=dataSAD;
    lbl="SAD Light Index";
    yCfg={min:0,max:100};
}

const dsBase={
label:base.name,
data:data.base,
borderColor:"#0b5fb3",
borderWidth:2.5,
tension:.3,
fill:false,
pointRadius:0
};
const dsComp={
label:comp.name,
data:data.comp,
borderColor:"#f28e2b",
borderWidth:2.5,
tension:.3,
fill:false,
pointRadius:0
};
const datasets=[dsBase,dsComp];
const annotations={};

if(mode==='elev'){
const threshold=dataElev.threshold;
annotations.threshold={
type:"line",
yMin:threshold,
yMax:threshold,
borderColor:"rgba(11,95,179,0.4)",
borderWidth:2,
borderDash:[5,5],
label:{
enabled:true,
content:`${base.name} Dec 21: ${threshold.toFixed(1)}¬∞`,
position:"end",
backgroundColor:"rgba(255,255,255,.9)",
color:"#0b5fb3",
font:{size:11}
}
};
const below=daysRaw.map(d=>dataElev.comp[daysRaw.indexOf(d)]<threshold?threshold:null);
const shade={
label:`Below ${base.name} Dec 21`,
data:below,
backgroundColor:"rgba(11,95,179,0.12)",
borderWidth:0,
type:"line",
pointRadius:0,
fill:true
};
datasets.splice(1,0,shade);
if(refElev!==undefined){
annotations.angleHorizontal={
type:"line",
yMin:refElev,
yMax:refElev,
borderColor:"#10b981",
borderWidth:2.5,
borderDash:[5,5],
label:{
enabled:true,
content:`${base.name} angle: ${refElev.toFixed(1)}¬∞`,
position:"start",
backgroundColor:"rgba(255,255,255,.95)",
color:"#10b981",
font:{size:11,weight:"bold"}
}
};
}
}

if(mode==='sad'){
    // Add threshold lines for SAD categories
    annotations.excellent={
        type:"line",
        yMin:85,
        yMax:85,
        borderColor:"rgba(245,158,11,0.4)",
        borderWidth:1,
        borderDash:[3,3]
    };
    annotations.good={
        type:"line",
        yMin:70,
        yMax:70,
        borderColor:"rgba(132,204,22,0.4)",
        borderWidth:1,
        borderDash:[3,3]
    };
    annotations.moderate={
        type:"line",
        yMin:55,
        yMax:55,
        borderColor:"rgba(34,211,238,0.4)",
        borderWidth:1,
        borderDash:[3,3]
    };
    annotations.low={
        type:"line",
        yMin:40,
        yMax:40,
        borderColor:"rgba(167,139,250,0.4)",
        borderWidth:1,
        borderDash:[3,3]
    };
}

const refIdx=daysRaw.indexOf(refDay);
if(refIdx!==-1){
annotations.selected={
type:"line",
xMin:refIdx+1,
xMax:refIdx+1,
borderColor:"#1e293b",
borderWidth:2.5,
label:{
enabled:true,
content:fmtMD(dateFromDay(new Date().getFullYear(),refDay)),
position:"start",
backgroundColor:"rgba(255,255,255,.95)",
color:"#1e293b",
font:{size:11,weight:"bold"}
}
};
}
if(eqDate && mode!=='sad'){
const eqD=dayOfYear(eqDate);
const eqIdx=daysRaw.indexOf(eqD);
if(eqIdx!==-1){
annotations.equiv={
type:"line",
xMin:eqIdx+1,
xMax:eqIdx+1,
borderColor:"#e11d48",
borderWidth:2.5,
label:{
enabled:true,
content:fmtMD(eqDate),
position:"start",
backgroundColor:"rgba(255,255,255,.95)",
color:"#e11d48",
font:{size:11,weight:"bold"}
}
};
}
}
if(chart)chart.destroy();
chart=new Chart(ctx,{
type:"line",
data:{labels:days,datasets},
options:{
responsive:true,
maintainAspectRatio:false,
animation:false,
plugins:{
legend:{
display:true,
position:"bottom",
labels:{
usePointStyle:true,
padding:15,
font:{size:12}
}
},
annotation:{annotations}
},
scales:{
x:{display:false},
y:{
title:{
display:true,
text:lbl,
font:{size:13,weight:"600"}
},
...yCfg,
grid:{color:"#e2e8f0"}
}
}
},
plugins:[Chart.registry.getPlugin("annotation")]
});
}

function updateAll(){
const refIdx=document.getElementById("referenceCity").selectedIndex;
const compIdx=document.getElementById("compareCity").selectedIndex;
const base=cities[refIdx];
const comp=cities[compIdx];
const sliderVal=Number(document.getElementById("dateSlider").value);
const date=dateFromDay(new Date().getFullYear(),sliderVal);
const day=sliderVal;
const eqDate=findEquivalentDate(comp.lat,daylightHours(base.lat,day),day,date.getFullYear());
const refElev=noonElevation(base.lat,day);
const angleDate=findEquivalentAngleDate(comp.lat,refElev,day,date.getFullYear());
document.getElementById("selectedLabel").textContent=fmtMD(date);
document.getElementById("equivLabel").textContent=eqDate?fmtMD(eqDate):"‚Äî";
buildTable(base,comp,day,mode);
chartData=prepareChartData(base,comp);
drawChart(day,eqDate,angleDate,refElev);
drawEarth(day);

// Show/hide cloud control
document.getElementById('cloudControl').style.display = mode==='sad' ? 'flex' : 'none';
}

function updateAnnotationsOnly(){
const refIdx=document.getElementById("referenceCity").selectedIndex;
const compIdx=document.getElementById("compareCity").selectedIndex;
const base=cities[refIdx];
const comp=cities[compIdx];
const sliderVal=Number(document.getElementById("dateSlider").value);
const date=dateFromDay(new Date().getFullYear(),sliderVal);
const day=sliderVal;
const eqDate=findEquivalentDate(comp.lat,daylightHours(base.lat,day),day,date.getFullYear());
const refElev=noonElevation(base.lat,day);
const angleDate=findEquivalentAngleDate(comp.lat,refElev,day,date.getFullYear());
document.getElementById("selectedLabel").textContent=fmtMD(date);
document.getElementById("equivLabel").textContent=eqDate?fmtMD(eqDate):"‚Äî";
buildTable(base,comp,day,mode);
drawChart(day,eqDate,angleDate,refElev);
drawEarth(day);
}

// Smoothstep function for smooth interpolation
function smoothstep(edge0, edge1, x) {
    const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
    return t * t * (3 - 2 * t);
}

// Precomputed stars for consistent rendering
let starsCache = null;
function getStars(w, h) {
    if (!starsCache || starsCache.w !== w || starsCache.h !== h) {
        const stars = [];
        // Use seeded random for consistent star positions
        let rand = 12345;
        const random = () => {
            rand = (rand * 1103515245 + 12345) & 0x7fffffff;
            return rand / 0x7fffffff;
        };
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: random() * w,
                y: random() * h,
                r: random() * 1.2 + 0.3,
                brightness: random() * 0.5 + 0.5
            });
        }
        starsCache = { w, h, stars };
    }
    return starsCache.stars;
}

// City lights data (approximate major city locations)
const cityLights = [
    // North America
    {lat: 40.7, lon: -74.0, size: 3},    // NYC
    {lat: 34.0, lon: -118.2, size: 2.5}, // LA
    {lat: 41.9, lon: -87.6, size: 2},    // Chicago
    {lat: 29.8, lon: -95.4, size: 1.8},  // Houston
    {lat: 33.4, lon: -112.1, size: 1.5}, // Phoenix
    {lat: 39.7, lon: -104.9, size: 1.5}, // Denver
    {lat: 47.6, lon: -122.3, size: 1.5}, // Seattle
    {lat: 25.8, lon: -80.2, size: 1.8},  // Miami
    {lat: 43.7, lon: -79.4, size: 1.8},  // Toronto
    {lat: 19.4, lon: -99.1, size: 2.5},  // Mexico City
    // South America
    {lat: -23.5, lon: -46.6, size: 2.5}, // Sao Paulo
    {lat: -34.6, lon: -58.4, size: 2},   // Buenos Aires
    {lat: -22.9, lon: -43.2, size: 2},   // Rio
    {lat: 4.7, lon: -74.1, size: 1.5},   // Bogota
    {lat: -12.0, lon: -77.0, size: 1.5}, // Lima
    // Europe
    {lat: 51.5, lon: -0.1, size: 2.5},   // London
    {lat: 48.9, lon: 2.3, size: 2.5},    // Paris
    {lat: 52.5, lon: 13.4, size: 2},     // Berlin
    {lat: 41.9, lon: 12.5, size: 2},     // Rome
    {lat: 40.4, lon: -3.7, size: 2},     // Madrid
    // Africa
    {lat: 30.0, lon: 31.2, size: 2},     // Cairo
    {lat: -33.9, lon: 18.4, size: 1.5},  // Cape Town
    {lat: 6.5, lon: 3.4, size: 2},       // Lagos
];

function drawEarth(day) {
    const canvas = document.getElementById('earthCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;
    const radius = w * 0.45;

    // View centered on Tampa FL
    const viewLat = 27.95;
    const viewLon = -82.46;
    const viewLatR = toRad(viewLat);
    const viewLonR = toRad(viewLon);

    ctx.clearRect(0, 0, w, h);

    // Draw space background
    const spaceGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, w * 0.7);
    spaceGrad.addColorStop(0, '#0a0a1a');
    spaceGrad.addColorStop(0.5, '#050510');
    spaceGrad.addColorStop(1, '#000000');
    ctx.fillStyle = spaceGrad;
    ctx.fillRect(0, 0, w, h);

    // Draw stars (consistent positions)
    const stars = getStars(w, h);
    stars.forEach(star => {
        ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
        ctx.fill();
    });

    // Calculate solar declination
    const declination = solarDeclination(day);
    const decRad = toRad(declination);

    // Create Earth with pixel-by-pixel rendering for smooth terminator
    const imageData = ctx.createImageData(w, h);
    const data = imageData.data;

    // Continent polygon data (simplified but more detailed)
    const continents = {
        northAmerica: [
            [70,-140],[72,-120],[70,-100],[65,-85],[60,-75],[55,-60],[50,-55],
            [45,-65],[42,-70],[38,-75],[35,-78],[30,-82],[28,-82],[25,-80],
            [25,-85],[27,-97],[26,-98],[22,-100],[18,-105],[15,-95],[18,-88],
            [21,-87],[22,-90],[25,-90],[28,-95],[29,-104],[32,-115],[35,-120],
            [40,-124],[45,-124],[50,-127],[55,-130],[60,-140],[65,-145],[70,-140]
        ],
        centralAmerica: [
            [18,-88],[15,-88],[12,-85],[10,-84],[8,-80],[9,-78],[10,-75],
            [8,-77],[7,-77],[9,-80],[10,-83],[14,-87],[18,-88]
        ],
        southAmerica: [
            [10,-75],[12,-72],[12,-68],[10,-65],[6,-60],[4,-52],[0,-50],
            [-5,-35],[-10,-37],[-15,-40],[-20,-42],[-25,-48],[-30,-52],
            [-35,-58],[-40,-65],[-45,-68],[-50,-72],[-55,-68],[-55,-65],
            [-52,-60],[-48,-65],[-42,-63],[-35,-55],[-28,-49],[-22,-42],
            [-15,-45],[-10,-50],[-5,-55],[0,-60],[2,-68],[5,-73],[10,-75]
        ],
        europe: [
            [70,30],[65,25],[60,30],[55,38],[50,40],[45,40],[40,30],
            [37,25],[36,28],[38,30],[40,25],[42,18],[43,10],[44,5],
            [46,0],[48,-5],[50,0],[52,5],[55,10],[58,15],[60,20],
            [62,25],[65,28],[70,30]
        ],
        africa: [
            [35,10],[37,-5],[35,-10],[30,-15],[25,-17],[20,-17],[15,-17],
            [10,-15],[5,-8],[0,-5],[-5,10],[-10,15],[-15,20],[-20,25],
            [-25,30],[-30,32],[-35,20],[-35,27],[-30,35],[-25,40],
            [-15,42],[-10,45],[0,45],[5,42],[10,40],[15,45],[20,50],
            [25,52],[30,35],[32,32],[35,30],[35,10]
        ],
        australia: [
            [-12,130],[-15,125],[-20,118],[-25,114],[-30,115],[-35,118],
            [-38,142],[-35,148],[-30,153],[-25,152],[-20,148],[-15,145],
            [-12,142],[-10,145],[-12,135],[-12,130]
        ],
        greenland: [
            [76,-20],[80,-30],[82,-40],[80,-55],[75,-60],[70,-55],
            [68,-45],[70,-35],[72,-25],[76,-20]
        ]
    };

    // Function to check if a point is inside a polygon (ray casting)
    function pointInPolygon(lat, lon, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i][1], yi = polygon[i][0];
            const xj = polygon[j][1], yj = polygon[j][0];
            if (((yi > lat) !== (yj > lat)) && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        return inside;
    }

    function isLand(lat, lon) {
        // Normalize longitude
        while (lon > 180) lon -= 360;
        while (lon < -180) lon += 360;
        
        for (const continent of Object.values(continents)) {
            if (pointInPolygon(lat, lon, continent)) return true;
        }
        return false;
    }

    // Render Earth pixel by pixel
    for (let py = 0; py < h; py++) {
        for (let px = 0; px < w; px++) {
            const dx = px - cx;
            const dy = py - cy;
            const distSq = dx * dx + dy * dy;
            const radiusSq = radius * radius;

            if (distSq <= radiusSq) {
                const x = dx / radius;
                const y = -dy / radius;
                const rho = Math.sqrt(x * x + y * y);

                if (rho <= 1 && rho > 0.001) {
                    // Inverse orthographic projection
                    const c = Math.asin(rho);
                    const cosC = Math.cos(c);
                    const sinC = Math.sin(c);
                    const cosViewLat = Math.cos(viewLatR);
                    const sinViewLat = Math.sin(viewLatR);

                    const latR = Math.asin(cosC * sinViewLat + (y * sinC * cosViewLat) / rho);
                    const lonR = viewLonR + Math.atan2(x * sinC, rho * cosViewLat * cosC - y * sinViewLat * sinC);
                    const lat = toDeg(latR);
                    let lon = toDeg(lonR);
                    while (lon > 180) lon -= 360;
                    while (lon < -180) lon += 360;

                    // Calculate sun angle for smooth terminator
                    const sunLon = 0;
                    const dLon = toRad(lon - sunLon);
                    const sinAlt = Math.sin(latR) * Math.sin(decRad) + Math.cos(latR) * Math.cos(decRad) * Math.cos(dLon);
                    const sunAngleDeg = toDeg(Math.asin(sinAlt));

                    // Smooth day/night blend using smoothstep (-12¬∞ to 6¬∞ transition)
                    const dayAmount = smoothstep(-12, 6, sunAngleDeg);
                    const nightAmount = 1 - dayAmount;

                    // Determine if land or ocean
                    const land = isLand(lat, lon);

                    // Limb darkening
                    const limbFactor = 1 - (rho * rho * 0.25);

                    // Day colors
                    let dayR, dayG, dayB;
                    if (land) {
                        // Land: greens and browns
                        const latFactor = Math.abs(lat) / 90;
                        if (Math.abs(lat) > 65) {
                            // Ice/snow
                            dayR = 240; dayG = 245; dayB = 250;
                        } else if (Math.abs(lat) > 50) {
                            // Northern forests
                            dayR = 60 + latFactor * 40; 
                            dayG = 100 + latFactor * 30; 
                            dayB = 50;
                        } else if (Math.abs(lat) < 25) {
                            // Tropical
                            dayR = 50; dayG = 130; dayB = 50;
                        } else {
                            // Temperate
                            dayR = 80; dayG = 120; dayB = 60;
                        }
                    } else {
                        // Ocean: blues
                        const depthVariation = Math.sin(lat * 0.1) * 10;
                        dayR = 30 + depthVariation;
                        dayG = 80 + depthVariation;
                        dayB = 160 + depthVariation;
                    }

                    // Night colors (dark with potential city lights)
                    let nightR = 5, nightG = 5, nightB = 15;
                    
                    // Add city lights on night side
                    if (land && nightAmount > 0.3) {
                        for (const city of cityLights) {
                            const dLat = lat - city.lat;
                            const dLon = lon - city.lon;
                            const dist = Math.sqrt(dLat * dLat + dLon * dLon);
                            if (dist < city.size * 3) {
                                const glow = Math.exp(-dist / city.size) * nightAmount;
                                nightR += glow * 255 * 0.9;
                                nightG += glow * 200 * 0.7;
                                nightB += glow * 100 * 0.3;
                            }
                        }
                    }

                    // Blend day and night
                    let r = dayR * dayAmount * limbFactor + nightR * nightAmount;
                    let g = dayG * dayAmount * limbFactor + nightG * nightAmount;
                    let b = dayB * dayAmount * limbFactor + nightB * nightAmount;

                    // Add subtle atmosphere at edges
                    if (rho > 0.85) {
                        const atmosBlend = (rho - 0.85) / 0.15;
                        r = r * (1 - atmosBlend * 0.3) + 100 * atmosBlend * 0.3;
                        g = g * (1 - atmosBlend * 0.3) + 150 * atmosBlend * 0.3;
                        b = b * (1 - atmosBlend * 0.3) + 255 * atmosBlend * 0.3;
                    }

                    const idx = (py * w + px) * 4;
                    data[idx] = Math.min(255, Math.max(0, r));
                    data[idx + 1] = Math.min(255, Math.max(0, g));
                    data[idx + 2] = Math.min(255, Math.max(0, b));
                    data[idx + 3] = 255;
                } else if (rho <= 0.001) {
                    // Center pixel
                    const idx = (py * w + px) * 4;
                    data[idx] = 30; data[idx + 1] = 80; data[idx + 2] = 160; data[idx + 3] = 255;
                }
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);

    // Draw atmospheric glow (blue limb)
    const glowGrad = ctx.createRadialGradient(cx, cy, radius * 0.92, cx, cy, radius * 1.12);
    glowGrad.addColorStop(0, 'rgba(100, 180, 255, 0)');
    glowGrad.addColorStop(0.4, 'rgba(120, 180, 255, 0.12)');
    glowGrad.addColorStop(0.7, 'rgba(80, 140, 220, 0.08)');
    glowGrad.addColorStop(1, 'rgba(50, 100, 180, 0)');
    ctx.fillStyle = glowGrad;
    ctx.beginPath();
    ctx.arc(cx, cy, radius * 1.12, 0, Math.PI * 2);
    ctx.fill();

    // Draw sun indicator
    const sunVisualAngle = declination > 0 ? -Math.PI / 3.5 : -Math.PI / 2.5;
    const sunDist = radius * 1.35;
    const sunX = cx + sunDist * Math.cos(sunVisualAngle);
    const sunY = cy + sunDist * Math.sin(sunVisualAngle);

    // Sun glow
    const sunGlowGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 20);
    sunGlowGrad.addColorStop(0, 'rgba(255, 250, 220, 1)');
    sunGlowGrad.addColorStop(0.3, 'rgba(255, 240, 150, 0.8)');
    sunGlowGrad.addColorStop(0.6, 'rgba(255, 220, 100, 0.3)');
    sunGlowGrad.addColorStop(1, 'rgba(255, 200, 80, 0)');
    ctx.fillStyle = sunGlowGrad;
    ctx.beginPath();
    ctx.arc(sunX, sunY, 20, 0, Math.PI * 2);
    ctx.fill();

    // Sun core
    ctx.fillStyle = '#fffef0';
    ctx.beginPath();
    ctx.arc(sunX, sunY, 6, 0, Math.PI * 2);
    ctx.fill();

    // Date label
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px -apple-system, BlinkMacSystemFont, sans-serif';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0,0,0,0.9)';
    ctx.shadowBlur = 4;
    const dateStr = fmtMD(dateFromDay(new Date().getFullYear(), day));
    ctx.fillText(dateStr, cx, h - 12);
    ctx.shadowBlur = 0;
}

function syncFromSlider(){
updateAnnotationsOnly();
}

function populateSelectors(){
const refSel=document.getElementById("referenceCity");
const compSel=document.getElementById("compareCity");
cities.forEach((c,i)=>{
const opt1=document.createElement("option");
opt1.value=i;
opt1.textContent=`${c.name}, ${c.country}`;
refSel.appendChild(opt1);
const opt2=document.createElement("option");
opt2.value=i;
opt2.textContent=`${c.name}, ${c.country}`;
compSel.appendChild(opt2);
});
}

function findClosestCity(lat,lon){
let closest=0,minDist=Infinity;
cities.forEach((c,i)=>{
const dist=Math.sqrt((c.lat-lat)**2+(c.lon-lon)**2);
if(dist<minDist){
minDist=dist;
closest=i;
}
});
return closest;
}

function initWithGeolocation(){
if(navigator.geolocation){
navigator.geolocation.getCurrentPosition(pos=>{
const closest=findClosestCity(pos.coords.latitude,pos.coords.longitude);
document.getElementById("referenceCity").selectedIndex=closest;
updateAll();
},err=>{
console.log('Geolocation error:',err);
// Default to Tampa if geolocation fails
const tampaIndex=cities.findIndex(c=>c.name==="Tampa, FL");
document.getElementById("referenceCity").selectedIndex=tampaIndex>=0?tampaIndex:0;
updateAll();
},{timeout:5000,enableHighAccuracy:false});
}else{
// Default to Tampa if geolocation not available
const tampaIndex=cities.findIndex(c=>c.name==="Tampa, FL");
document.getElementById("referenceCity").selectedIndex=tampaIndex>=0?tampaIndex:0;
updateAll();
}
}

function init(){
populateSelectors();
document.getElementById("compareCity").selectedIndex=16;
const now=new Date();
document.getElementById("dateSlider").value=dayOfYear(now);
initWithGeolocation();
}

document.getElementById("dateSlider").addEventListener("input",syncFromSlider);
document.getElementById("referenceCity").addEventListener("change",updateAll);
document.getElementById("compareCity").addEventListener("change",updateAll);

// Cloud slider for SAD mode
document.getElementById("cloudSlider").addEventListener("input",function(){
    document.getElementById("cloudValue").textContent=this.value+'%';
    if(mode==='sad'){
        chartData=prepareChartData(chartData.base,chartData.comp);
        updateAnnotationsOnly();
    }
});

document.getElementById("hoursBtn").addEventListener("click",()=>{
mode="hours";
hoursBtn.classList.add("active");
hoursBtn.classList.remove("active-green");
elevBtn.classList.remove("active");
elevBtn.classList.remove("active-green");
sadBtn.classList.remove("active");
sadBtn.classList.remove("active-green");
updateAll();
});
document.getElementById("elevBtn").addEventListener("click",()=>{
mode="elev";
elevBtn.classList.add("active");
elevBtn.classList.remove("active-green");
hoursBtn.classList.remove("active");
hoursBtn.classList.remove("active-green");
sadBtn.classList.remove("active");
sadBtn.classList.remove("active-green");
updateAll();
});
document.getElementById("sadBtn").addEventListener("click",()=>{
mode="sad";
sadBtn.classList.add("active-green");
sadBtn.classList.remove("active");
hoursBtn.classList.remove("active");
hoursBtn.classList.remove("active-green");
elevBtn.classList.remove("active");
elevBtn.classList.remove("active-green");
updateAll();
});
window.addEventListener("DOMContentLoaded",init);
</script>
</body>
</html>
